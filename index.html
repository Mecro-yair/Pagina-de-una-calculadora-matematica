<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trabajo de Modelado Computacional</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #1e1e2e;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 1px solid rgba(147, 51, 234, 0.2);
        }
        header {
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            animation: shine 3s infinite;
        }
        @keyframes shine {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }
        h1 { font-size: 2.5em; margin-bottom: 10px; position: relative; z-index: 1; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .subtitle { opacity: 0.95; font-size: 1.1em; position: relative; z-index: 1; }
        .content { padding: 40px; }
        .method-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .method-btn {
            padding: 15px;
            border: 2px solid #7c3aed;
            background: #2a2a3e;
            color: #c4b5fd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
            font-weight: 600;
        }
        .method-btn:hover {
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(124, 58, 237, 0.4);
            border-color: #a855f7;
        }
        .method-btn.active { 
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            color: white;
            box-shadow: 0 8px 20px rgba(124, 58, 237, 0.4);
        }
        .input-section {
            background: #2a2a3e;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid rgba(147, 51, 234, 0.2);
        }
        .input-group { margin-bottom: 20px; }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #c4b5fd;
        }
        input, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #3d3d54;
            background: #1e1e2e;
            color: #e5e5e5;
            border-radius: 8px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }
        textarea { min-height: 100px; resize: vertical; }
        input:focus, textarea:focus { 
            outline: none; 
            border-color: #7c3aed;
            box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.2);
        }
        .help-text { font-size: 0.9em; color: #9ca3af; margin-top: 5px; }
        .solve-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(124, 58, 237, 0.3);
        }
        .solve-btn:hover { 
            transform: scale(1.02);
            box-shadow: 0 6px 20px rgba(124, 58, 237, 0.5);
        }
        .result-section {
            background: #2a2a3e;
            padding: 25px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
            border-left: 5px solid #7c3aed;
            border: 1px solid rgba(147, 51, 234, 0.3);
        }
        .result-section.show { display: block; }
        .result-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #c4b5fd;
            margin-bottom: 15px;
        }
        .result-content {
            background: #1e1e2e;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            line-height: 1.6;
            color: #e5e5e5;
            border: 1px solid #3d3d54;
        }
        .error { 
            background: #3d1f1f; 
            border-color: #dc2626;
        }
        .error .result-title { color: #fca5a5; }
        .error .result-content { 
            background: #2d1515;
            color: #fca5a5;
            border-color: #7f1d1d;
        }
        .credits-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            padding: 15px 25px;
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);
            transition: all 0.3s;
            z-index: 1000;
        }
        .credits-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(124, 58, 237, 0.6);
        }
        .credits-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .credits-modal.show { display: flex; }
        .credits-content {
            background: #1e1e2e;
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
            border: 1px solid rgba(147, 51, 234, 0.3);
        }
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .credits-header { text-align: center; margin-bottom: 30px; }
        .credits-header h2 { font-size: 2em; color: #c4b5fd; margin-bottom: 10px; }
        .credits-header p { color: #9ca3af; font-size: 1.1em; }
        .credits-list { list-style: none; padding: 0; }
        .credits-list li {
            padding: 15px;
            margin: 10px 0;
            background: #2a2a3e;
            border-left: 4px solid #7c3aed;
            border-radius: 8px;
            font-size: 1.05em;
            font-weight: 500;
            color: #e5e5e5;
            transition: all 0.3s;
        }
        .credits-list li:hover {
            transform: translateX(5px);
            box-shadow: 0 3px 10px rgba(124, 58, 237, 0.3);
            background: #323246;
        }
        .credits-close {
            display: block;
            margin: 30px auto 0;
            padding: 12px 40px;
            background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .credits-close:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(124, 58, 237, 0.4);
        }
        #plotSection {
            display: none;
            margin-top: 20px;
            padding: 25px;
            background: #2a2a3e;
            border-radius: 10px;
            border: 1px solid rgba(147, 51, 234, 0.2);
        }
        #plotSection > div:first-child {
            font-size: 1.2em;
            font-weight: 600;
            color: #c4b5fd;
            margin-bottom: 15px;
        }
        #plotCanvas {
            border: 2px solid #3d3d54;
            border-radius: 8px;
            background: #1e1e2e;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            max-width: 100%;
        }
        @media (max-width: 768px) {
            body { padding: 10px; }
            h1 { font-size: 1.8em; }
            .subtitle { font-size: 0.95em; }
            .content { padding: 20px; }
            .method-selector {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 10px;
            }
            .method-btn { padding: 12px; font-size: 0.9em; }
            .input-section { padding: 15px; }
            .result-section { padding: 15px; }
            canvas { width: 100%; height: auto; }
            input, textarea { font-size: 16px; }
            .credits-btn {
                bottom: 20px;
                right: 20px;
                padding: 12px 20px;
                font-size: 0.9em;
            }
            .credits-content { padding: 25px; }
            .credits-header h2 { font-size: 1.5em; }
            .credits-list li { font-size: 0.95em; padding: 12px; }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1.5em; }
            .method-selector { grid-template-columns: 1fr; }
            .method-btn { padding: 10px; font-size: 0.85em; }
            .content { padding: 15px; }
            .input-section { padding: 12px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Trabajo de Modelado Computacional para Ingeniería</h1>
            <p class="subtitle">Algoritmos Vistos en Clase</p>
        </header>

        <div class="content">
            <div class="method-selector">
                <button class="method-btn" data-method="suma">Suma Matrices</button>
                <button class="method-btn" data-method="multiplicacion">Multiplicación</button>
                <button class="method-btn" data-method="determinante">Determinante</button>
                <button class="method-btn" data-method="inversa">Matriz Inversa</button>
                <button class="method-btn" data-method="gauss">Gauss</button>
                <button class="method-btn" data-method="gauss-jordan">Gauss-Jordan</button>
                <button class="method-btn" data-method="jacobi">Jacobi</button>
                <button class="method-btn" data-method="gauss-seidel">Gauss-Seidel</button>
                <button class="method-btn" data-method="no-lineal">Ec. No Lineales</button>
                <button class="method-btn" data-method="punto-fijo">Punto Fijo</button>
                <button class="method-btn" data-method="newton-mod">Newton Modificado</button>
                <button class="method-btn" data-method="biseccion">Bisección</button>
                <button class="method-btn" data-method="secante">Secante</button>
            </div>

            <div class="input-section" id="inputSection"></div>

            <div class="result-section" id="resultSection">
                <div class="result-title">Resultado:</div>
                <div class="result-content" id="resultContent"></div>
            </div>

            <div id="plotSection">
                <div>Gráfica del Sistema (2 variables)</div>
                <div style="display: flex; justify-content: center;">
                    <canvas id="plotCanvas" width="600" height="400"></canvas>
                </div>
                <div style="margin-top: 10px; font-size: 0.9em; color: #9ca3af; text-align: center;">
                    La gráfica solo está disponible para sistemas de 2 ecuaciones con 2 variables (x, y)
                </div>
            </div>
        </div>
    </div>

    <button class="credits-btn" onclick="toggleCredits()">Créditos</button>

    <div class="credits-modal" id="creditsModal">
        <div class="credits-content">
            <div class="credits-header">
                <h2>Desarrollado por</h2>
                <p>Equipo de Trabajo</p>
            </div>
            <ul class="credits-list">
                <li>OSCAR ALEJANDRO TICONA FERNANDEZ</li>
                <li>DANNY YAIR LUQUE PARI</li>
                <li>WESLEY RIVALDO LAURA CHOQUEJAHUA</li>
                <li>YHULIAN NAYELI MAQUERA FLORES</li>
                <li>ALEXANDRA 2_NOMBRE 1_APELLIDO 2_APELLIDO</li>
            </ul>
            <button class="credits-close" onclick="toggleCredits()">Cerrar</button>
        </div>
    </div>

    <script>
        let currentMethod = null;

        function toggleCredits() {
            document.getElementById('creditsModal').classList.toggle('show');
        }

        document.addEventListener('click', function(e) {
            const modal = document.getElementById('creditsModal');
            if (e.target === modal) modal.classList.remove('show');
        });

        function sumaMatrices(A, B) {
            return A.map((row, i) => row.map((val, j) => val + B[i][j]));
        }

        function multiplicacionMatrices(A, B) {
            return A.map((row, i) => 
                B[0].map((_, j) => 
                    row.reduce((sum, val, k) => sum + val * B[k][j], 0)
                )
            );
        }

        function determinante(A) {
            const n = A.length;
            if (n === 1) return A[0][0];
            if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0];
            return A[0].reduce((sum, val, j) => {
                const sub = A.slice(1).map(row => row.filter((_, k) => k !== j));
                return sum + Math.pow(-1, j) * val * determinante(sub);
            }, 0);
        }

        function matrizInversa(A) {
            const n = A.length;
            const det = determinante(A);
            if (Math.abs(det) < 1e-10) throw new Error("Matriz singular");
            const aug = A.map((row, i) => [...row, ...Array(n).fill(0).map((_, j) => i === j ? 1 : 0)]);
            for (let k = 0; k < n; k++) {
                const pivot = aug[k][k];
                for (let j = 0; j < 2 * n; j++) aug[k][j] /= pivot;
                for (let i = 0; i < n; i++) {
                    if (i !== k) {
                        const f = aug[i][k];
                        for (let j = 0; j < 2 * n; j++) aug[i][j] -= f * aug[k][j];
                    }
                }
            }
            return aug.map(row => row.slice(n));
        }

        function gaussElimination(A, b) {
            const n = b.length;
            const M = A.map((row, i) => [...row, b[i]]);
            for (let k = 0; k < n; k++) {
                let maxRow = k;
                for (let i = k + 1; i < n; i++) {
                    if (Math.abs(M[i][k]) > Math.abs(M[maxRow][k])) maxRow = i;
                }
                [M[k], M[maxRow]] = [M[maxRow], M[k]];
                for (let i = k + 1; i < n; i++) {
                    const f = M[i][k] / M[k][k];
                    for (let j = k; j <= n; j++) M[i][j] -= f * M[k][j];
                }
            }
            const x = Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = (M[i][n] - M[i].slice(i + 1, n).reduce((s, v, j) => s + v * x[i + 1 + j], 0)) / M[i][i];
            }
            return x;
        }

        function gaussJordan(A, b) {
            const n = b.length;
            const M = A.map((row, i) => [...row, b[i]]);
            for (let k = 0; k < n; k++) {
                const p = M[k][k];
                for (let j = 0; j <= n; j++) M[k][j] /= p;
                for (let i = 0; i < n; i++) {
                    if (i !== k) {
                        const f = M[i][k];
                        for (let j = 0; j <= n; j++) M[i][j] -= f * M[k][j];
                    }
                }
            }
            return M.map(row => row[n]);
        }

        function jacobi(A, b, tol = 1e-6, maxIter = 100) {
            const n = b.length;
            let x = Array(n).fill(0);
            for (let iter = 0; iter < maxIter; iter++) {
                const xNew = x.map((_, i) => (b[i] - A[i].reduce((s, v, j) => s + (j !== i ? v * x[j] : 0), 0)) / A[i][i]);
                if (Math.max(...xNew.map((v, i) => Math.abs(v - x[i]))) < tol) return { x: xNew, iterations: iter + 1 };
                x = xNew;
            }
            return { x, iterations: maxIter };
        }

        function gaussSeidel(A, b, tol = 1e-6, maxIter = 100) {
            const n = b.length;
            let x = Array(n).fill(0);
            for (let iter = 0; iter < maxIter; iter++) {
                const xOld = [...x];
                for (let i = 0; i < n; i++) {
                    x[i] = (b[i] - A[i].reduce((s, v, j) => s + (j !== i ? v * x[j] : 0), 0)) / A[i][i];
                }
                if (Math.max(...x.map((v, i) => Math.abs(v - xOld[i]))) < tol) return { x, iterations: iter + 1 };
            }
            return { x, iterations: maxIter };
        }

        function bisection(f, a, b, tol = 1e-8, maxIt = 100) {
            let fa = f(a), fb = f(b);
            if (fa * fb > 0) throw new Error("No hay cambio de signo");
            const rows = [];
            for (let k = 1; k <= maxIt; k++) {
                const r = (a + b) / 2, fr = f(r);
                rows.push({ k, a, b, r, fr });
                if (Math.abs(fr) < tol || (b - a) / 2 < tol) break;
                if (fa * fr < 0) { b = r; fb = fr; } else { a = r; fa = fr; }
            }
            return rows;
        }

        function secant(f, x0, x1, tol = 1e-8, maxIt = 100) {
            const rows = [];
            for (let k = 1; k <= maxIt; k++) {
                const fx0 = f(x0), fx1 = f(x1);
                if (fx1 === fx0) throw new Error("Denominador cero");
                const x2 = x1 - fx1 * (x1 - x0) / (fx1 - fx0), fx2 = f(x2);
                rows.push({ k, x0, x1, x2, fx1, fx2 });
                if (Math.abs(x2 - x1) < tol || Math.abs(fx2) < tol) break;
                x0 = x1; x1 = x2;
            }
            return rows;
        }

        function parseMatrix(s) { return s.trim().split('\n').map(r => r.trim().split(/\s+/).map(parseFloat)); }
        function parseVector(s) { return s.trim().split(/\s+/).map(parseFloat); }
        function formatMatrix(M) { return M.map(r => r.map(x => x.toFixed(4)).join('  ')).join('\n'); }
        function formatVector(v) { return v.map(x => x.toFixed(6)).join('\n'); }

        function showResult(content, isError = false) {
            const sec = document.getElementById('resultSection');
            const cont = document.getElementById('resultContent');
            sec.className = 'result-section show' + (isError ? ' error' : '');
            cont.textContent = content;
            document.getElementById('plotSection').style.display = 'none';
        }

        function preprocessEq(eq, n) {
            const vars = ['x', 'y', 'z', 'w', 'u', 'v', 't', 's', 'r', 'q'];
            let p = eq.trim()
                .replace(/\bsen\(/g, 'Math.sin(')
                .replace(/\bcos\(/g, 'Math.cos(')
                .replace(/\btan\(/g, 'Math.tan(')
                .replace(/\bln\(/g, 'Math.log(')
                .replace(/\blog\(/g, 'Math.log10(')
                .replace(/\bexp\(/g, 'Math.exp(')
                .replace(/\b(raiz|sqrt)\(/g, 'Math.sqrt(')
                .replace(/²/g, '**2').replace(/³/g, '**3');
            for (let i = 0; i < n; i++) p = p.replace(new RegExp(`\\b${vars[i]}\\b`, 'g'), `v[${i}]`);
            return p;
        }

        function solveMatrixOperation() {
            try {
                const A = parseMatrix(document.getElementById('matrixA').value);
                const B = parseMatrix(document.getElementById('matrixB').value);
                const result = currentMethod === 'suma' ? sumaMatrices(A, B) : multiplicacionMatrices(A, B);
                showResult(`Resultado de A ${currentMethod === 'suma' ? '+' : '×'} B:\n\n${formatMatrix(result)}`);
            } catch (e) { showResult('Error: ' + e.message, true); }
        }

        function solveMatrixSingle() {
            try {
                const M = parseMatrix(document.getElementById('matrix').value);
                if (currentMethod === 'determinante') {
                    showResult('Determinante: ' + determinante(M).toFixed(6));
                } else {
                    showResult('Matriz Inversa:\n\n' + formatMatrix(matrizInversa(M)));
                }
            } catch (e) { showResult('Error: ' + e.message, true); }
        }

        function solveLinearSystem() {
            try {
                const A = parseMatrix(document.getElementById('matrixA').value);
                const b = parseVector(document.getElementById('vectorB').value);
                let result, output;
                if (currentMethod === 'gauss') {
                    result = gaussElimination(A, b);
                    output = 'Solución (Gauss):\n\n' + formatVector(result);
                } else if (currentMethod === 'gauss-jordan') {
                    result = gaussJordan(A, b);
                    output = 'Solución (Gauss-Jordan):\n\n' + formatVector(result);
                } else if (currentMethod === 'jacobi') {
                    result = jacobi(A, b);
                    output = `Solución (Jacobi):\n\n${formatVector(result.x)}\n\nIteraciones: ${result.iterations}`;
                } else {
                    result = gaussSeidel(A, b);
                    output = `Solución (Gauss-Seidel):\n\n${formatVector(result.x)}\n\nIteraciones: ${result.iterations}`;
                }
                showResult(output);
            } catch (e) { showResult('Error: ' + e.message, true); }
        }

        function solveNonLinear() {
            try {
                const eqs = document.getElementById('equations').value.trim().split('\n').filter(e => e.trim());
                const initial = parseVector(document.getElementById('initial').value);
                const proc = eqs.map(eq => preprocessEq(eq, initial.length));
                const f = v => proc.map(eq => eval(eq));
                let v = [...initial];
                const h = 1e-8, tol = 1e-6, maxIter = 100;
                let finalIter = 0;
                for (let iter = 0; iter < maxIter; iter++) {
                    finalIter = iter + 1;
                    const fv = f(v);
                    if (Math.sqrt(fv.reduce((s, x) => s + x * x, 0)) < tol) break;
                    const J = fv.map((_, i) => v.map((_, j) => {
                        const vh = [...v]; vh[j] += h;
                        return (f(vh)[i] - fv[i]) / h;
                    }));
                    const delta = gaussElimination(J, fv.map(x => -x));
                    v = v.map((x, i) => x + delta[i]);
                    if (Math.max(...delta.map(Math.abs)) < tol) break;
                }
                const err = Math.sqrt(f(v).reduce((s, x) => s + x * x, 0));
                const vars = ['x', 'y', 'z', 'w', 'u'];
                let output = 'Solución aproximada:\n\n';
                v.forEach((val, i) => output += `${vars[i]} = ${val.toFixed(10)}\n`);
                output += `\nIteraciones: ${finalIter}\nError residual: ${err.toExponential(4)}`;
                showResult(output);
                if (initial.length === 2) {
                    document.getElementById('plotSection').style.display = 'block';
                    setTimeout(() => plotSystem(proc, v), 100);
                }
            } catch (e) { showResult('Error: ' + e.message, true); }
        }

        function solvePuntoFijo() {
            try {
                const gFuncs = document.getElementById('equations').value.trim().split('\n').filter(e => e.trim());
                const initial = parseVector(document.getElementById('initial').value);
                if (gFuncs.length !== initial.length) throw new Error("Número de funciones debe igualar variables");
                const proc = gFuncs.map(g => preprocessEq(g, initial.length));
                const g = v => proc.map(eq => eval(eq));
                let v = [...initial];
                const tol = 1e-8, maxIter = 100;
                let finalIter = 0, history = [];
                for (let k = 1; k <= maxIter; k++) {
                    finalIter = k;
                    const vNew = g(v);
                    const err = Math.max(...vNew.map((x, i) => Math.abs(x - v[i])));
                    history.push({ iter: k, vNew, err });
                    v = vNew;
                    if (err < tol) break;
                    if (k === maxIter) throw new Error('No convergió');
                }
                const vars = ['x', 'y', 'z', 'w', 'u'];
                let output = 'Solución (Punto Fijo):\n\n';
                v.forEach((val, i) => output += `${vars[i]} = ${val.toFixed(10)}\n`);
                output += `\nIteraciones: ${finalIter}\nError final: ${history[history.length - 1].err.toExponential(4)}`;
                showResult(output);
            } catch (e) { showResult('Error: ' + e.message, true); }
        }

        function solveNewtonModificado() {
            try {
                const eqs = document.getElementById('equations').value.trim().split('\n').filter(e => e.trim());
                const initial = parseVector(document.getElementById('initial').value);
                if (eqs.length !== initial.length) throw new Error("Número de ecuaciones debe igualar variables");
                const proc = eqs.map(eq => preprocessEq(eq, initial.length));
                const f = v => proc.map(eq => eval(eq));
                const h = 1e-8;
                const f0 = f(initial);
                const J0 = f0.map((_, i) => initial.map((_, j) => {
                    const vh = [...initial]; vh[j] += h;
                    return (f(vh)[i] - f0[i]) / h;
                }));
                let v = [...initial];
                const tol = 1e-8, maxIter = 50;
                let finalIter = 0, history = [];
                for (let k = 1; k <= maxIter; k++) {
                    finalIter = k;
                    const fv = f(v);
                    const delta = gaussElimination(J0, fv.map(x => -x));
                    v = v.map((x, i) => x + delta[i]);
                    const err = Math.max(...delta.map(Math.abs));
                    const resnorm = Math.sqrt(fv.reduce((s, x) => s + x * x, 0));
                    history.push({ iter: k, err, resnorm });
                    if (err < tol && resnorm < tol) break;
                    if (k === maxIter) throw new Error('No convergió');
                }
                const vars = ['x', 'y', 'z', 'w', 'u'];
                let output = 'Solución (Newton Modificado):\n\n';
                v.forEach((val, i) => output += `${vars[i]} = ${val.toFixed(10)}\n`);
                output += `\nIteraciones: ${finalIter}\nError: ${history[history.length - 1].err.toExponential(4)}`;
                output += `\nNorma residual: ${history[history.length - 1].resnorm.toExponential(4)}`;
                output += '\n\nNOTA: Jacobiano calculado solo en x₀';
                showResult(output);
            } catch (e) { showResult('Error: ' + e.message, true); }
        }

        function solveRootFinding() {
            try {
                let funcStr = document.getElementById('function').value
                    .replace(/\bsen\(/g, 'Math.sin(').replace(/\bcos\(/g, 'Math.cos(')
                    .replace(/\btan\(/g, 'Math.tan(').replace(/\bln\(/g, 'Math.log(')
                    .replace(/\blog\(/g, 'Math.log10(').replace(/\bexp\(/g, 'Math.exp(')
                    .replace(/\b(raiz|sqrt)\(/g, 'Math.sqrt(').replace(/²/g, '**2').replace(/³/g, '**3');
                const f = x => eval(funcStr);
                const [a, b] = parseVector(document.getElementById('interval').value);
                let rows, output;
                if (currentMethod === 'biseccion') {
                    rows = bisection(f, a, b);
                    output = 'Método de Bisección:\n\nIter\ta\t\tb\t\tr\t\tf(r)\n';
                    rows.slice(0, 6).forEach(r => output += `${r.k}\t${r.a.toFixed(6)}\t${r.b.toFixed(6)}\t${r.r.toFixed(6)}\t${r.fr.toFixed(8)}\n`);
                    if (rows.length > 6) output += `...\n${rows[rows.length - 1].k}\t${rows[rows.length - 1].r.toFixed(6)}\t\t\t${rows[rows.length - 1].fr.toFixed(8)}\n`;
                    output += `\nRaíz aproximada: ${rows[rows.length - 1].r.toFixed(10)}\nIteraciones: ${rows.length}`;
                } else {
                    rows = secant(f, a, b);
                    output = 'Método de la Secante:\n\nIter\tx0\t\tx1\t\tx2\t\tf(x2)\n';
                    rows.forEach(r => output += `${r.k}\t${r.x0.toFixed(6)}\t${r.x1.toFixed(6)}\t${r.x2.toFixed(6)}\t${r.fx2.toFixed(8)}\n`);
                    output += `\nRaíz aproximada: ${rows[rows.length - 1].x2.toFixed(10)}\nIteraciones: ${rows.length}`;
                }
                showResult(output);
            } catch (e) { showResult('Error: ' + e.message, true); }
        }

        function plotSystem(eqs, sol) {
            const canvas = document.getElementById('plotCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            ctx.fillStyle = '#1e1e2e';
            ctx.fillRect(0, 0, w, h);
            const [solX, solY] = sol, range = 4;
            const xMin = solX - range, xMax = solX + range, yMin = solY - range, yMax = solY + range;
            const toPixelX = x => ((x - xMin) / (xMax - xMin)) * w;
            const toPixelY = y => h - ((y - yMin) / (yMax - yMin)) * h;
            ctx.strokeStyle = '#2a2a3e';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 20; i++) {
                const px = toPixelX(xMin + (xMax - xMin) * i / 20);
                ctx.beginPath();
                ctx.moveTo(px, 0);
                ctx.lineTo(px, h);
                ctx.stroke();
                const py = toPixelY(yMin + (yMax - yMin) * i / 20);
                ctx.beginPath();
                ctx.moveTo(0, py);
                ctx.lineTo(w, py);
                ctx.stroke();
            }
            ctx.strokeStyle = '#4a4a5e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (yMin <= 0 && yMax >= 0) {
                const y0 = toPixelY(0);
                ctx.moveTo(0, y0);
                ctx.lineTo(w, y0);
            }
            if (xMin <= 0 && xMax >= 0) {
                const x0 = toPixelX(0);
                ctx.moveTo(x0, 0);
                ctx.lineTo(x0, h);
            }
            ctx.stroke();
            const colors = ['#f87171', '#60a5fa'];
            const gridSize = 400;
            eqs.forEach((eq, idx) => {
                const grid = [];
                for (let i = 0; i <= gridSize; i++) {
                    grid[i] = [];
                    for (let j = 0; j <= gridSize; j++) {
                        const x = xMin + (xMax - xMin) * i / gridSize;
                        const y = yMin + (yMax - yMin) * j / gridSize;
                        try { grid[i][j] = eval(eq); } catch { grid[i][j] = NaN; }
                    }
                }
                ctx.strokeStyle = colors[idx];
                ctx.lineWidth = 3;
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const v00 = grid[i][j], v10 = grid[i + 1][j], v01 = grid[i][j + 1], v11 = grid[i + 1][j + 1];
                        if ([v00, v10, v01, v11].some(isNaN)) continue;
                        const signs = [v00 > 0, v10 > 0, v01 > 0, v11 > 0];
                        if (signs.some(s => s) && signs.some(s => !s)) {
                            const x1 = xMin + (xMax - xMin) * i / gridSize;
                            const x2 = xMin + (xMax - xMin) * (i + 1) / gridSize;
                            const y1 = yMin + (yMax - yMin) * j / gridSize;
                            const y2 = yMin + (yMax - yMin) * (j + 1) / gridSize;
                            const pts = [];
                            if ((v00 > 0) !== (v10 > 0)) pts.push([x1 + Math.abs(v00) / (Math.abs(v00) + Math.abs(v10)) * (x2 - x1), y1]);
                            if ((v10 > 0) !== (v11 > 0)) pts.push([x2, y1 + Math.abs(v10) / (Math.abs(v10) + Math.abs(v11)) * (y2 - y1)]);
                            if ((v01 > 0) !== (v11 > 0)) pts.push([x1 + Math.abs(v01) / (Math.abs(v01) + Math.abs(v11)) * (x2 - x1), y2]);
                            if ((v00 > 0) !== (v01 > 0)) pts.push([x1, y1 + Math.abs(v00) / (Math.abs(v00) + Math.abs(v01)) * (y2 - y1)]);
                            if (pts.length >= 2) {
                                ctx.beginPath();
                                ctx.moveTo(toPixelX(pts[0][0]), toPixelY(pts[0][1]));
                                for (let k = 1; k < pts.length; k++) ctx.lineTo(toPixelX(pts[k][0]), toPixelY(pts[k][1]));
                                ctx.stroke();
                            }
                        }
                    }
                }
            });
            ctx.shadowColor = 'rgba(124, 58, 237, 0.6)';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#a855f7';
            ctx.beginPath();
            ctx.arc(toPixelX(solX), toPixelY(solY), 8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#1e1e2e';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        function createInputUI(method) {
            const sec = document.getElementById('inputSection');
            let html = '';
            if (['suma', 'multiplicacion'].includes(method)) {
                html = `<div class="input-group"><label>Matriz A:</label><textarea id="matrixA" placeholder="1 2&#10;3 4"></textarea></div>
                        <div class="input-group"><label>Matriz B:</label><textarea id="matrixB" placeholder="5 6&#10;7 8"></textarea></div>
                        <button class="solve-btn" onclick="solveMatrixOperation()">Calcular</button>`;
            } else if (['determinante', 'inversa'].includes(method)) {
                html = `<div class="input-group"><label>Matriz:</label><textarea id="matrix" placeholder="4 2&#10;3 1"></textarea></div>
                        <button class="solve-btn" onclick="solveMatrixSingle()">Calcular</button>`;
            } else if (['gauss', 'gauss-jordan', 'jacobi', 'gauss-seidel'].includes(method)) {
                html = `<div class="input-group"><label>Matriz A:</label><textarea id="matrixA" placeholder="2 3&#10;1 -1"></textarea></div>
                        <div class="input-group"><label>Vector b:</label><input type="text" id="vectorB" placeholder="8 1"></div>
                        <button class="solve-btn" onclick="solveLinearSystem()">Resolver</button>`;
            } else if (method === 'no-lineal') {
                html = `<div class="input-group"><label>Ecuaciones:</label><textarea id="equations" placeholder="x**2 + y**2 - 4&#10;exp(x) + y - 1"></textarea>
                        <div class="help-text">Variables: x, y, z. Funciones: sen(), cos(), ln(), exp(), raiz()</div></div>
                        <div class="input-group"><label>Punto inicial:</label><input type="text" id="initial" placeholder="0.5 0.5"></div>
                        <button class="solve-btn" onclick="solveNonLinear()">Resolver</button>`;
            } else if (method === 'punto-fijo') {
                html = `<div class="input-group"><label>Funciones g(x):</label><textarea id="equations" placeholder="cos(y)&#10;sen(x)"></textarea>
                        <div class="help-text">Sistema x = g(x). Escribir cada componente de g.</div></div>
                        <div class="input-group"><label>Punto inicial:</label><input type="text" id="initial" placeholder="0.5 0.5"></div>
                        <button class="solve-btn" onclick="solvePuntoFijo()">Resolver</button>`;
            } else if (method === 'newton-mod') {
                html = `<div class="input-group"><label>Ecuaciones f(x) = 0:</label><textarea id="equations" placeholder="x**2 + y + z - 4&#10;y**2 + z + x - 5"></textarea>
                        <div class="help-text">Jacobiano calculado solo en x₀</div></div>
                        <div class="input-group"><label>Punto inicial:</label><input type="text" id="initial" placeholder="1 1 1"></div>
                        <button class="solve-btn" onclick="solveNewtonModificado()">Resolver</button>`;
            } else if (['biseccion', 'secante'].includes(method)) {
                html = `<div class="input-group"><label>Función f(x):</label><input type="text" id="function" placeholder="x**3 - x - 2">
                        <div class="help-text">Funciones: sen(), cos(), ln(), exp(), raiz()</div></div>
                        <div class="input-group"><label>Intervalo [a, b]:</label><input type="text" id="interval" placeholder="1 2"></div>
                        <button class="solve-btn" onclick="solveRootFinding()">Resolver</button>`;
            }
            sec.innerHTML = html;
        }

        document.querySelectorAll('.method-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentMethod = this.dataset.method;
                createInputUI(currentMethod);
                document.getElementById('resultSection').classList.remove('show');
                document.getElementById('plotSection').style.display = 'none';
            });
        });

        document.querySelector('.method-btn').click();
    </script>
</body>
</html>
